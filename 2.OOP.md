### Constructor Function
> In JavaScript, a constructor function is used to create and initialize objects. It's defined like a regular function and
  typically invoked with the new keyword to create object instances.

```
function BankAccount(customerName, balance = 0) {
  this.customerName = customerName;
  this.accountNumber = Date.now();
  this.balance = balance;

  this.deposit = function (amount) {
    this.balance += amount;
  };

   this.withdraw = (amount) => {
       this.balance -= amount;
   };
}

 const rakeshAccount = new BankAccount('Rakesh K', 1000);
 const johnAccount = new BankAccount('John Doe');
 rakeshAccount.deposit(5000);
 johnAccount.deposit(1000);
 rakeshAccount.withdraw(2000);

 console.log(rakeshAccount, johnAccount);

```

---
### Prototype
> Javascript object inherit feature from one another
```
// Create a parent object
const parent = {
  parentProperty: 'I am from the parent',
};

// Create a child object that inherits from the parent
const child = Object.create(parent);
child.childProperty = 'I am from the child';

// Access properties from both child and parent
console.log(child.childProperty); // Output: "I am from the child"
console.log(child.parentProperty); // Output: "I am from the parent"

// The prototype chain allows the child to inherit properties from the parent

```
```
function BankAccount(customerName, balance = 0) {
  this.customerName = customerName;
  this.accountNumber = Date.now();
  this.balance = balance;
}

BankAccount.prototype.deposit = function (amount) {
  this.balance += amount;
};

BankAccount.prototype.withdraw = function (amount) {
  if (amount <= this.balance) {
    this.balance -= amount;
  } else {
    console.log("Insufficient funds.");
  }
};

const accounts = [];

const accountForm = document.querySelector('#accountForm');
const customerName = document.querySelector('#customerName');
const balance = document.querySelector('#balance');

const depositForm = document.querySelector('#depositForm');
const accountNumber = document.querySelector('#accountNumber');
const amount = document.querySelector('#amount');

accountForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const account = new BankAccount(customerName.value, +balance.value);
  accounts.push(account);
  console.log(accounts);
});

depositForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const account = accounts.find(
    (account) => account.accountNumber === +accountNumber.value
  );
  if (account) {
    account.deposit(+amount.value);
  } else {
    console.log("Account not found.");
  }
  console.log(accounts);
});

```
#### Protype inheritance
```
class BankAccount {
    customerName;
    accountNumber;
    balance = 0;

    constructor(customerName, balance = 0) {
        this.customerName = customerName;
        this.accountNumber = Date.now();
        this.balance = balance;
    }

    deposit(amount) {
        this.balance += amount;
    }

    withdraw(amount) {
        this.balance -= amount;
    }
}

class CurrentAccount extends BankAccount {
    transactionLimit = 50000;

    constructor(customerName, balance = 0) {
        super(customerName, balance);
    }

    takeBusinessLoan(amount) {
        console.log('Taking business loan: ' + amount);
    }
}

class SavingAccount extends BankAccount {
    transactionLimit = 10000;

    constructor(customerName, balance = 0) {
        super(customerName, balance);
    }

    takePersonalLoan(amount) {
        console.log('Taking personal loan: ' + amount);
    }
}

const rakeshAccount = new SavingAccount('Rakesh K', 500);
rakeshAccount.deposit(500);
rakeshAccount.withdraw(100);
rakeshAccount.takePersonalLoan(40000);
console.log(rakeshAccount);
```
#### Object Prototype:

The prototype of an object can be accessed using the Object.getPrototypeOf(object) method or the __proto__ property. 
The Object.prototype is the top of the prototype chain.
```
// Create an object
const myObject = {
  prop: "I'm a property of myObject",
};

// Access the prototype of myObject using Object.getPrototypeOf(object)
const objectPrototype = Object.getPrototypeOf(myObject);

// Access the prototype using __proto__
const protoUsing__proto = myObject.__proto__;

// Access a property from the Object.prototype
const toStringMethod = Object.prototype.toString;

console.log(objectPrototype === protoUsing__proto); // true
console.log(toStringMethod === Object.prototype.toString); // true

// Now, let's check if myObject has inherited properties from its prototype
console.log(myObject.prop); // Output: "I'm a property of myObject"

// Since myObject doesn't have its own property, it inherits from its prototype.
```
---
### Classes
> JavaScript classes are a syntactical feature introduced in ES6 for creating objects with properties and methods in a more organized and class-based manner,
```
class BankAccount {
    customerName;
    accountNumber;
    balance = 0;

    constructor(customerName, balance = 0) {
        this.customerName = customerName;
        this.accountNumber = Date.now();
        this.balance = balance;
    }

    deposit(amount) {
        this.balance += amount;
    }

    withdraw(amount) {
        this.balance -= amount;
    }
}

 const rakeshAccount = new BankAccount('Rakesh K', 1000);
 rakeshAccount.deposit(4000);

 const johnAccount = new BankAccount('John Doe');
 johnAccount.deposit(500);
 johnAccount.withdraw(200);
 console.log(rakeshAccount);
```
### Encapsulation
> OOPs restrict direct access to its methods and variables by encapsulating the code and data together.
```
class BankAccount {
    customerName;
    accountNumber;
    #balance = 0;

    constructor(customerName, balance = 0) {
        this.customerName = customerName;
        this.accountNumber = Date.now();
        this.#balance = balance;
    }

    deposit(amount) {
        this.#balance += amount;
    }

    withdraw(amount) {
        this.#balance -= amount;
    }

    set balance(amount) {
        if (isNaN(amount)) {
            throw new Error('Amount is not a valid input');
        }
        this.#balance = amount;
    }

    get balance() {
        return this.#balance;
    }
}

class CurrentAccount extends BankAccount {
    transactionLimit = 50000;

    constructor(customerName, balance = 0) {
        super(customerName, balance);
    }

    #calculateInterest(amount) {
        console.log('Calculating interest');
    }

    takeBusinessLoan(amount) {
        // Logic
        this.#calculateInterest(amount);
        console.log('Taking business loan: ' + amount);
    }
}

const rakeshAccount = new CurrentAccount('Rakesh K', 2000);
// rakeshAccount.setBalance(400);
// rakeshAccount.balance = 5000;
rakeshAccount.takeBusinessLoan(40000);
console.log(rakeshAccount);
```
### Static method and property
> In JavaScript, static properties and methods are values or functions directly connected to a class, not its instances. They are shared among all instances, like class-wide information or tools. Static properties and methods provide a way to store and access data and functions at the class level, not tied to individual objects.

```
// class Config {
//     static dbUser = 'usename';
//     static dbPassword = 'secret';
//     static apiToken = 'abcd';
// }

// console.log(Config.apiToken);

// // Increment
class User {
    // static id = 1;
    static cache = {
        1: 'some value',
    };

    constructor(name, age, income) {
        this.name = name;
        this.age = age;
        this.income = income;
        this.id = User.id++;
    }

    // checkCache() {}

    static {
        console.log('Initialized');
    }

    static hasInCache() {
        console.log(User.cache);
    }

    // static compareByAge(user1, user2) {
    //     return user1.age - user2.age;
    // }

    // static compareByIncome(user1, user2) {
    //     return user1.income - user2.income;
    // }
}

// User.hasInCache();
// const user1 = new User('Rakesh K', 30, 5000);
User.hasInCache();
User.hasInCache();
// const user2 = new User('John Doe', 40, 10000);
// const user3 = new User('Jane Doe', 20, 7000);

// console.log(user1, user2, user3);
```
